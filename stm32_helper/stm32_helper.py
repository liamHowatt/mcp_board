import argparse
import subprocess
import os
import os.path
import posixpath
import shutil
import sys
import json
from itertools import chain

def parse_args():
    parser = argparse.ArgumentParser(
        prog="stm32_helper",
        formatter_class=argparse.RawTextHelpFormatter,
        description="""Automate the management of an STM32CubeMX project.
You will want to use STM32CubeMX to generate the driver files and inital Makefile \
and then invoke this tool with "post_cube" and then "build".""",
        epilog="See the README for more info."
    )
    parser.add_argument("--gcc-path", help="directory where arm-none-eabi-* tools are")
    parser.add_argument("--make-arg", action="append", default=[], dest="make_args",
        help="add an arg to the make invokation"
    )
    parser.add_argument("--pyocd-venv-path", help="python that has pyocd installed")
    parser.add_argument("--pyocd-arg", action="append", default=[], dest="pyocd_args",
        help="add an arg to the pyocd invokation"
    )
    parser.add_argument("--gdb-arg", action="append", default=[], dest="gdb_args",
        help="add an arg to the gdb invokation"
    )
    parser.add_argument("action", choices=(
        "post_cube",
        "build",
        "upload",
        "debug",
        "reset_mcu",
        "clean",
    ), help="""task to perform.
post_cube: postprocess the makefile and source files generated by STM32CubeMX. \
run this command each time CubeMX is run or your own source files are created/renamed/deleted.
build: run "make"
upload: upload the binary using pyocd
debug: run pyocd's gdb-server and gdb
reset_mcu: reset the MCU using pyocd
clean: delete everything in the stm32cubemx directory except the .ioc file""")
    return parser.parse_args()

def main():
    CUBE_DIR = "stm32cubemx"

    args = parse_args()
    # print(args)

    assert CUBE_DIR in os.listdir(), f"Must be invoked in a directory that contains a {CUBE_DIR} directory"

    if args.action == "post_cube":

        main_c_path = os.path.join(CUBE_DIR, "Src", "main.c")
        app_h_include = "#include \"app.h\""
        with open(main_c_path) as f:
            main_c = f.read()
        # only do this if it hasn't already been done
        if not main_c.startswith(app_h_include):
            app_main_call = "  app_main();\n"
            assert app_main_call not in main_c # shouldn't be in here yet
            parts = main_c.partition("/* USER CODE BEGIN 2 */\n")
            assert parts[1]
            with open(main_c_path, "w") as f:
                f.write(app_h_include)
                f.write("\n\n")
                f.write(parts[0])
                f.write(parts[1])
                f.write(app_main_call)
                f.write(parts[2])

        makefile_path = os.path.join(CUBE_DIR, "Makefile")
        makefile_bak_path = os.path.join(CUBE_DIR, "Makefile.bak")
        # create a backup of the makefile to restore if the user runs this
        # after restructuring their own source directories.
        # if "clean" was run, no backup will exist yet and cube will
        # have created a new makefile which needs to be backed up
        if os.path.isfile(makefile_bak_path):
            shutil.copyfile(makefile_bak_path, makefile_path)
        else:
            shutil.copyfile(makefile_path, makefile_bak_path)
        with open(makefile_path) as f:
            makefile = f.read()

        # bug where CubeMX dosen't generate the m0plus flag for STM32C series MCUs
        m0flag = "CPU = -mcpu=cortex-m0plus\n"
        cpu_comment = "# cpu\n"
        if m0flag not in makefile:
            assert makefile.count(cpu_comment) == 1
            makefile = makefile.replace(cpu_comment, cpu_comment + m0flag)

        cfg = get_cfg()
        imports = cfg.get("imports", ())
        excludes = set(cfg.get("excludes", ()))
        with open(makefile_path, "w") as f:
            parts = makefile.partition("C_SOURCES =  \\\n")
            assert parts[1]
            f.write(parts[0])
            f.write(parts[1])
            # f.write("".join(s + " \\\n" for s in subprocess.run("find -L app -name *.c", shell=True, capture_output=True).stdout.decode().splitlines()))
            f.write("".join(s + " \\\n" for s in chain.from_iterable(
                (posixpath.join("..", lib, file) for file in os.listdir(lib) if file.endswith(".c") and posixpath.join(lib, file) not in excludes)
                for lib
                in imports
            )))
            parts = parts[2].partition("# CFLAGS\n#######################################\n")
            assert parts[1]
            f.write(parts[0])
            f.write(parts[1])
            f.write(f"CFLAGS += {cfg.get('additional_cflags', '')}\n\n")
            parts = parts[2].partition("C_INCLUDES =  \\\n")
            assert parts[1]
            f.write(parts[0])
            f.write(parts[1])
            # f.write("".join("-I" + s + " \\\n" for s in subprocess.run("find -L app -name *.h | xargs dirname", shell=True, capture_output=True).stdout.decode().splitlines()))
            f.write("".join(f"-I{s} \\\n" for s in (posixpath.join("..", lib) for lib in imports)))
            f.write(parts[2])

        shutil.rmtree(os.path.join(CUBE_DIR, "build"), ignore_errors=True)

    elif args.action == "build":
        cfg = get_cfg()
        subprocess.check_call(
            tuple(chain(("make", "-C", CUBE_DIR), cfg.get("make_args", ()), args.make_args)),
            env={**os.environ, "GCC_PATH": args.gcc_path} if args.gcc_path is not None else None
        )
    elif args.action == "upload":
        cfg = get_cfg()
        project_name = cfg["project_name"]
        pyocd(subprocess.check_call, args.pyocd_venv_path, (
            "load",
            *args.pyocd_args,
            *cfg.get("pyocd_args", ()),
            os.path.join(
                CUBE_DIR,
                "build",
                project_name + ".elf"
            )
        ))
    elif args.action == "debug":
        gdb_path = (
            os.path.join(args.gcc_path, "arm-none-eabi-gdb")
            if args.gcc_path is not None
            else "arm-none-eabi-gdb"
        )
        cfg = get_cfg()
        project_name = cfg["project_name"]
        pyocd(subprocess.Popen, args.pyocd_venv_path, (
            "gdb",
            *args.pyocd_args,
        ))
        # breakpoint()
        subprocess.run((
            gdb_path,
            os.path.join(
                CUBE_DIR,
                "build",
                project_name + ".elf"
            ),
            "-ex", "target remote localhost:3333",
            *args.gdb_args,
        ))
    elif args.action == "reset_mcu":
        pyocd(subprocess.check_call, args.pyocd_venv_path, (
            "reset",
            *args.pyocd_args,
        ))
    elif args.action == "clean":
        for ent in os.listdir(CUBE_DIR):
            ent_full = os.path.join(CUBE_DIR, ent)
            if os.path.isfile(ent_full):
                if ent.endswith(".ioc"):
                    continue
                os.remove(ent_full)
            else:
                shutil.rmtree(ent_full)

loaded_cfg = None
def get_cfg():
    global loaded_cfg
    if loaded_cfg is None:
        with open("stm32_helper_configs.json") as f:
            loaded_cfg = json.load(f)
    return loaded_cfg

def pyocd(runner, py_path, args):
    if py_path is None:
        py_path = sys.executable
    cfg = get_cfg()
    pyocd_target = cfg["pyocd_target"]
    pyocd_args = cfg.get("pyocd_args", ())
    return runner((py_path, "-m", "pyocd", *args, *pyocd_args, "--target", pyocd_target))

if __name__ == "__main__":
    main()
